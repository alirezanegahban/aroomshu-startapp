# سند معماری فنی (Technical Architecture Document)

**نسخه:** ۱.۰ | **تاریخ:** بهمن ۱۴۰۴ | **نویسنده:** امیر رضایی (CTO)

---

## ۱. مقدمه

این سند، معماری فنی سطح بالای پلتفرم "آروم‌شو" را تشریح می‌کند. هدف از این معماری، ایجاد یک سیستم **مقیاس‌پذیر، قابل نگهداری، امن و انعطاف‌پذیر** است که بتواند اهداف استراتژیک محصول و کسب‌وکار را در بلندمدت پشتیبانی کند. انتخاب‌های تکنولوژیک ما بر اساس نیازمندی‌های فعلی و پیش‌بینی رشد آینده صورت گرفته است.

## ۲. اصول معماری

معماری ما بر پایه اصول زیر بنا شده است:

-   **معماری میکروسرویس (Microservices Architecture):** برای جداسازی دغدغه‌ها (Separation of Concerns)، توسعه مستقل و مقیاس‌پذیری جداگانه هر بخش از سیستم.
-   **اول-API (API-First):** تمام منطق کسب‌وکار از طریق APIهای RESTful ارائه می‌شود تا کلاینت‌های مختلف (وب، موبایل) بتوانند از آن استفاده کنند.
-   **ابر-محور (Cloud-Native):** استفاده حداکثری از خدمات مدیریت‌شده ابری (Managed Services) برای کاهش بار عملیاتی و افزایش قابلیت اطمینان.
-   **امنیت در طراحی (Security by Design):** در نظر گرفتن ملاحظات امنیتی در تمام لایه‌های معماری از ابتدا.
-   **اتوماسیون (Automation):** خودکارسازی فرآیندهای ساخت، تست و استقرار (CI/CD) برای افزایش سرعت و کاهش خطای انسانی.

## ۳. نمای کلی معماری (High-Level Architecture Diagram)

(در این بخش یک دیاگرام قرار می‌گیرد که اجزای اصلی سیستم و نحوه تعامل آن‌ها را نشان می‌دهد. دیاگرام شامل بخش‌های زیر خواهد بود: کلاینت‌ها، Gateway API، سرویس‌های اصلی، پایگاه‌های داده، سرویس‌های شخص ثالث و زیرساخت ابری.)

**اجزای اصلی:**

1.  **کلاینت‌ها (Clients):**
    -   **اپلیکیشن وب (Single Page Application - SPA):** توسعه داده شده با React و TypeScript.
    -   **اپلیکیشن‌های موبایل (iOS & Android):** توسعه داده شده با React Native.

2.  **API Gateway:**
    -   به عنوان تنها نقطه ورود به سیستم عمل می‌کند.
    -   مسئولیت مسیریابی (Routing)، احراز هویت (Authentication)، محدودسازی نرخ درخواست (Rate Limiting) و کشینگ را بر عهده دارد.
    -   از **Amazon API Gateway** یا یک راهکار مشابه مانند Kong استفاده خواهد شد.

3.  **میکروسرویس‌ها (Microservices):**
    -   هر سرویس مسئول یک حوزه کسب‌وکار مشخص است و پایگاه داده خود را دارد.
    -   سرویس‌ها از طریق فراخوانی API (همزمان) یا از طریق یک گذرگاه رویداد (Event Bus) (غیرهمزمان) با یکدیگر ارتباط برقرار می‌کنند.

4.  **پایگاه‌های داده (Databases):**
    -   استفاده از پایگاه داده مناسب برای هر سرویس (Polyglot Persistence).

5.  **زیرساخت ابری (Cloud Infrastructure):**
    -   کل سیستم بر روی **Amazon Web Services (AWS)** مستقر خواهد شد.

## ۴. جزئیات میکروسرویس‌ها

در فاز اول، سرویس‌های اصلی زیر توسعه داده خواهند شد:

| سرویس | مسئولیت‌ها | تکنولوژی پیشنهادی (زبان، فریمورک) | پایگاه داده پیشنهادی |
| :--- | :--- | :--- | :--- |
| **سرویس کاربران (User Service)** | - ثبت‌نام، ورود، مدیریت پروفایل<br>- احراز هویت و مدیریت دسترسی (RBAC) | - Node.js / NestJS | PostgreSQL (Amazon RDS) |
| **سرویس ارزیابی (Assessment Service)** | - اجرای منطق ارزیاب هوشمند علائم<br>- مدیریت پروتکل‌ها و درخت‌های تصمیم | - Python / FastAPI | PostgreSQL (برای پروتکل‌ها) + Redis (برای کش کردن جلسات) |
| **سرویس محتوا (Content Service)** | - مدیریت مقالات، ویدیوها و دسته‌بندی‌ها<br>- ارائه API برای جستجو و فیلتر محتوا | - Node.js / Strapi (Headless CMS) | PostgreSQL |
| **سرویس کاتالوگ محصولات (Catalog Service)** | - مدیریت اطلاعات محصولات، قیمت‌ها و موجودی | - Node.js / NestJS | PostgreSQL |
| **سرویس سفارشات (Order Service)** | - مدیریت فرآیند خرید، پرداخت و تاریخچه سفارشات | - Node.js / NestJS | PostgreSQL |
| **سرویس نوتیفیکیشن (Notification Service)** | - ارسال ایمیل، پوش نوتیفیکیشن و پیامک | - Python / FastAPI | - (بدون پایگاه داده اصلی) |

## ۵. پشته فناوری (Technology Stack)

-   **فرانت‌اند وب:** React, TypeScript, Next.js (برای SSR/SEO), TailwindCSS
-   **فرانت‌اند موبایل:** React Native, TypeScript, Expo
-   **بک‌اند:** Node.js (NestJS) و Python (FastAPI) - انتخاب بر اساس نیاز سرویس
-   **پایگاه داده:** PostgreSQL, Redis
-   **زیرساخت:** AWS (ECS/EKS, S3, RDS, ElastiCache, API Gateway, Lambda)
-   **CI/CD:** GitHub Actions, Docker
-   **مانیتورینگ و لاگینگ:** Prometheus, Grafana, ELK Stack (Elasticsearch, Logstash, Kibana)
-   **گذرگاه رویداد (Event Bus):** Amazon SQS/SNS یا RabbitMQ

## ۶. معماری داده (Data Architecture)

-   **جداسازی داده‌ها:** هر میکروسرویس مالک داده‌های خود است و هیچ سرویس دیگری اجازه دسترسی مستقیم به پایگاه داده آن را ندارد.
-   **همگام‌سازی داده‌ها:** برای مواردی که نیاز به داده‌های ترکیبی است (مثلاً گزارش‌گیری)، از الگوی **Event Sourcing** و **CQRS (Command Query Responsibility Segregation)** استفاده خواهد شد. رویدادها (Events) در یک گذرگاه رویداد منتشر شده و سرویس‌های دیگر به آن‌ها گوش می‌دهند تا نمای محلی خود را به‌روز کنند.
-   **انبار داده (Data Warehouse):** برای تحلیل‌های پیچیده و هوش تجاری (BI)، داده‌ها از پایگاه‌های داده عملیاتی به صورت دوره‌ای به یک انبار داده مانند **Amazon Redshift** یا **Google BigQuery** منتقل خواهند شد.

## ۷. امنیت (Security)

-   **احراز هویت و مجوزدهی (Authentication & Authorization):** استفاده از پروتکل **OAuth 2.0** و **JWT (JSON Web Tokens)**. سرویس کاربران به عنوان سرور احراز هویت عمل خواهد کرد.
-   **امنیت API:** تمام ارتباطات بین کلاینت و سرور و بین سرویس‌ها باید از طریق **HTTPS/TLS** انجام شود. API Gateway مسئولیت اعتبارسنجی توکن‌های JWT را بر عهده دارد.
-   **حفاظت از داده‌ها:** رمزنگاری داده‌های حساس در حالت سکون (Encryption at Rest) و در حال انتقال (Encryption in Transit). اعمال سیاست‌های دسترسی سخت‌گیرانه (Principle of Least Privilege).
-   **مقابله با حملات رایج:** استفاده از ابزارها و تکنیک‌های استاندارد برای جلوگیری از حملات XSS, CSRF, SQL Injection و ...

## ۸. مقیاس‌پذیری و قابلیت اطمینان (Scalability & Reliability)

-   **مقیاس‌پذیری افقی:** میکروسرویس‌ها به صورت کانتینرهای داکر بسته‌بندی شده و بر روی یک ارکستریتور مانند **Amazon ECS** یا **Kubernetes (EKS)** اجرا می‌شوند. این به ما امکان می‌دهد تا تعداد نمونه‌های (Instances) هر سرویس را به صورت مستقل و بر اساس بار کاری، افزایش یا کاهش دهیم.
-   **قابلیت اطمینان:**
    -   استفاده از **Load Balancer** برای توزیع ترافیک بین نمونه‌های مختلف یک سرویس.
    -   طراحی سرویس‌ها به صورت **Stateless** تا حد امکان.
    -   استفاده از پایگاه‌های داده مدیریت‌شده (Managed Databases) با قابلیت Failover خودکار.
    -   پیاده‌سازی الگوهای تاب‌آوری (Resiliency Patterns) مانند **Circuit Breaker** و **Retry** در ارتباطات بین سرویسی.

## ۹. استراتژی استقرار (Deployment Strategy)

-   **محیط‌ها:** حداقل سه محیط مجزا خواهیم داشت: **توسعه (Development)، آزمایشی (Staging) و عملیاتی (Production)**.
-   **CI/CD:**
    1.  توسعه‌دهنده کد را به یک شاخه ویژگی (Feature Branch) در GitHub پوش می‌کند.
    2.  یک Pull Request ایجاد می‌شود و کد توسط همکاران بازبینی می‌شود.
    3.  پس از تایید، کد با شاخه اصلی (main) ادغام می‌شود.
    4.  **GitHub Actions** به طور خودکار فعال شده، تست‌ها را اجرا کرده، یک ایمیج داکر جدید می‌سازد و آن را در **Amazon ECR (Elastic Container Registry)** پوش می‌کند.
    5.  ایمیج جدید به صورت خودکار در محیط Staging مستقر می‌شود.
    6.  پس از تایید نهایی، استقرار در محیط Production به صورت دستی یا با استفاده از استراتژی **Blue/Green Deployment** برای به حداقل رساندن Downtime انجام می‌شود.
